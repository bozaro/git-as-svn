/*
 * This file is part of git-as-svn. It is subject to the license terms
 * in the LICENSE file found in the top-level directory of this distribution
 * and at http://www.gnu.org/licenses/gpl-2.0.html. No part of git-as-svn,
 * including this file, may be copied, modified, propagated, or distributed
 * except according to the terms contained in the LICENSE file.
 */
package svnserver.repository.git.prop

import org.eclipse.jgit.attributes.Attributes
import org.eclipse.jgit.attributes.AttributesNode
import org.eclipse.jgit.attributes.AttributesRule
import org.eclipse.jgit.errors.InvalidPatternException
import org.slf4j.Logger
import org.tmatesoft.svn.core.SVNProperty
import org.tmatesoft.svn.core.internal.wc.SVNFileUtil
import svnserver.*
import svnserver.repository.git.path.Wildcard
import java.io.*
import java.util.*
import java.util.regex.PatternSyntaxException

/**
 * Factory for properties, generated by .gitattributes.
 *
 * @author Artem V. Navrotskiy <bozaro@users.noreply.github.com>
 */
class GitAttributesFactory : GitPropertyFactory {
    override val fileName: String
        get() {
            return ".gitattributes"
        }

    @Throws(IOException::class)
    override fun create(stream: InputStream): Array<GitProperty> {
        val r = AttributesNode()
        r.parse(stream)
        val properties: MutableList<GitProperty> = ArrayList()
        for (rule: AttributesRule in r.rules) {
            val wildcard: Wildcard
            try {
                wildcard = Wildcard(rule.pattern)
            } catch (e: InvalidPatternException) {
                log.warn("Found invalid git pattern: {}", rule.pattern)
                continue
            } catch (e: PatternSyntaxException) {
                log.warn("Found invalid git pattern: {}", rule.pattern)
                continue
            }
            val attrs = Attributes(*rule.attributes.toTypedArray())
            val eolType: EolType? = getEolType(attrs)
            if (eolType != null) {
                processProperty(properties, wildcard, SVNProperty.MIME_TYPE, eolType.mimeType)
                processProperty(properties, wildcard, SVNProperty.EOL_STYLE, eolType.eolStyle)
            }
            processProperty(properties, wildcard, SVNProperty.NEEDS_LOCK, getNeedsLock(attrs))
            val filter: String? = getFilter(attrs)
            if (filter != null) properties.add(GitFilterProperty(wildcard.matcher, filter))
        }
        return properties.toTypedArray()
    }

    /**
     * @see EolStreamTypeUtil
     */
    private fun getEolType(attrs: Attributes): EolType? {
        if (attrs.isSet("binary") || attrs.isUnset("text")) return EolType.Binary
        val eol: String? = attrs.getValue("eol")
        if (eol != null) {
            when (eol) {
                "lf" -> return EolType.LF
                "crlf" -> return EolType.CRLF
            }
        }
        if (attrs.isUnspecified("text")) return null
        return EolType.Native
    }

    private enum class EolType(val mimeType: String, val eolStyle: String) {
        Binary(SVNFileUtil.BINARY_MIME_TYPE, ""), Native("", SVNProperty.EOL_STYLE_NATIVE), LF("", SVNProperty.EOL_STYLE_LF), CRLF("", SVNProperty.EOL_STYLE_CRLF);
    }

    private fun getNeedsLock(attrs: Attributes): String? {
        if (attrs.isSet("lockable")) return "*"
        return null
    }

    companion object {
        private val log: Logger = Loggers.git

        private fun processProperty(properties: MutableList<GitProperty>, wildcard: Wildcard, property: String, value: String?) {
            if (value == null) {
                return
            }
            if (value.isNotEmpty()) {
                if (wildcard.isSvnCompatible) {
                    properties.add(GitAutoProperty(wildcard.matcher, property, value))
                }
                properties.add(GitFileProperty(wildcard.matcher, property, value))
            } else {
                properties.add(GitFileProperty(wildcard.matcher, property, null))
            }
        }

        private fun getFilter(attrs: Attributes): String? {
            return attrs.getValue("filter")
        }
    }
}
